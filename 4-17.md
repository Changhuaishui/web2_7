# 微信文章爬虫系统调试记录 (2024-04-17)

## 问题概述

前端与后端交互过程中发现了两个关键问题：

1. **405 Method Not Allowed 错误**：前端尝试访问文章详情页面时，出现 HTTP 405 错误，表明请求方法不被允许
2. **MyBatis 主键生成异常**：后端在插入文章 HTML 内容时出现 "Could not determine which parameter to assign generated keys to" 错误

## 问题分析

### 前端 405 错误分析

通过分析发现：

- 前端使用 `GET` 方法请求 `/api/crawler/articles/detail/{id}` 接口，但后端没有对应的 GET 映射
- 响应头中 `allow: DELETE` 表明该路径只支持 DELETE 方法
- 前端需要的详情接口与后端删除文章的接口路径冲突

### MyBatis 异常分析

通过检查代码发现：

- `ArticleMapper.java` 中的 `insertArticleHtml` 方法使用了错误的 `keyProperty` 值
- 方法接收两个参数 `@Param("articleId") Integer articleId` 和 `@Param("fullHtml") String fullHtml`
- 但 `@Options(useGeneratedKeys = true, keyProperty = "id")` 中 `keyProperty` 设为 "id"，而不是 "articleId"
- MyBatis 无法将生成的主键赋值给正确的参数

## 解决方案

### 1. 前端请求方法修复

1. 在 `ArticleDetail.vue` 中修改请求方式：

```javascript
// 修改前
const response = await axios.get(`/api/crawler/articles/detail/${route.params.id}`);

// 修改后
const response = await axios.post('/api/crawler/articles/detail', {
  url: route.params.id
});
```

2. 增强错误处理和日志输出：

```javascript
catch (error) {
  console.error('加载文章失败:', error);
  console.error('请求URL:', error.config?.url);
  console.error('请求方法:', error.config?.method);
  console.error('支持的方法:', error.response?.headers?.allow);
  console.error('错误详情:', error.response?.data || error.message);
  ElMessage.error('加载文章失败：' + (error.response?.data || error.message))
}
```

### 2. 后端接口调整

1. 在 `CrawlerController.java` 中添加 POST 接口处理文章详情请求：

```java
@PostMapping("/articles/detail")
public ResponseEntity<?> getArticleDetailByUrl(@RequestBody Map<String, String> request) {
    try {
        String url = request.get("url");
        if (url == null || url.isEmpty()) {
            return ResponseEntity.badRequest().body("URL不能为空");
        }

        System.out.println("收到文章详情请求，URL: " + url);
        
        // URL解码
        String decodedUrl = java.net.URLDecoder.decode(url, "UTF-8");
        System.out.println("URL解码后: " + decodedUrl);

        // 尝试查找文章
        Article article = articleMapper.findByUrl(decodedUrl);
        
        // 如果找不到，尝试不同的URL变体
        if (article == null) {
            System.out.println("未找到精确匹配，尝试其他变体");
            String urlWithHttps = decodedUrl.startsWith("https://") ? decodedUrl : "https://" + decodedUrl;
            String urlWithoutHttps = decodedUrl.replace("https://", "").replace("http://", "");
            
            article = articleMapper.findByUrl(urlWithHttps);
            if (article == null) {
                article = articleMapper.findByUrl(urlWithoutHttps);
            }
            
            if (article == null) {
                System.out.println("所有URL变体都未找到匹配的文章");
                return ResponseEntity.status(404).body("未找到匹配的文章");
            }
        }

        // 获取文章HTML内容
        String fullHtml = null;
        if (article.getId() != null) {
            fullHtml = articleMapper.getArticleHtml(article.getId());
        }
        
        // 构建返回对象
        Map<String, Object> result = new java.util.HashMap<>();
        result.put("id", article.getId());
        result.put("title", article.getTitle());
        result.put("author", article.getAuthor());
        result.put("url", article.getUrl());
        result.put("sourceUrl", article.getSourceUrl());
        result.put("accountName", article.getAccountName());
        result.put("publishTime", article.getPublishTime());
        result.put("content", article.getContent());
        result.put("images", article.getImages());
        
        if (fullHtml != null) {
            result.put("fullHtml", fullHtml);
        }
        
        return ResponseEntity.ok(result);
    } catch (Exception e) {
        System.err.println("获取文章详情失败: " + e.getMessage());
        e.printStackTrace();
        return ResponseEntity.status(500).body("获取文章详情失败：" + e.getMessage());
    }
}
```

### 3. MyBatis 主键生成修复

1. 修改 `ArticleMapper.java` 中的 `insertArticleHtml` 方法：

```java
// 修改前
@Insert("INSERT INTO article_full_html (article_id, full_html) VALUES (#{articleId}, #{fullHtml})")
@Options(useGeneratedKeys = true, keyProperty = "id")
int insertArticleHtml(@Param("articleId") Integer articleId, @Param("fullHtml") String fullHtml);

// 修改后
@Insert("INSERT INTO article_full_html (article_id, full_html) VALUES (#{articleId}, #{fullHtml})")
@Options(useGeneratedKeys = true, keyProperty = "articleId")
int insertArticleHtml(@Param("articleId") Integer articleId, @Param("fullHtml") String fullHtml);
```

2. 增强 `DatabasePipeline.java` 中的错误处理和日志：

```java
// 获取新插入文章的ID
Article insertedArticle = articleMapper.findByUrl(url);
if (insertedArticle != null) {
    // 插入HTML内容
    Integer articleId = insertedArticle.getId();
    logger.info("Inserting HTML content for article ID: {}", articleId);
    articleMapper.insertArticleHtml(articleId, fullHtml);
    logger.info("Successfully inserted article and HTML content for URL: {}", url);
}
```

## 架构分析总结

通过这次调试，可以总结出系统架构的关键点：

### 前后端通信模式

1. **前端配置（端口：5173）**：
   - Vite 代理将 `/api` 请求转发到后端 `http://localhost:8081`
   - 解决跨域问题并处理编码

2. **后端配置（端口：8081）**：
   - Spring Boot 应用监听 8081 端口
   - 通过 `CorsConfig` 配置允许跨域请求

3. **数据流路径**：
   - 前端 → Vite 代理 → 后端 API → MyBatis → MySQL 数据库
   - 全文检索通过 Lucene 索引实现

### REST API 设计

- **GET /api/crawler/articles** - 获取所有文章
- **POST /api/crawler/articles/detail** - 获取文章详情
- **DELETE /api/crawler/articles/{url}** - 删除文章
- **POST /api/crawler/crawl** - 提交爬取任务

## 经验教训

1. **HTTP 方法匹配**：确保前端请求方法与后端 API 设计一致
2. **参数传递**：复杂参数（如 URL）应使用请求体传递，避免路径参数编码问题
3. **MyBatis 配置**：多参数方法中 `keyProperty` 需指定正确的参数名
4. **URL 处理**：处理包含特殊字符的 URL 时，需要正确编码和解码
5. **错误处理**：加强日志记录，便于定位和解决问题

## 后续优化方向

1. 统一 API 设计规范，确保 RESTful 风格一致性
2. 增强错误处理机制，提供更友好的用户提示
3. 考虑使用 DTO 对象传递数据，避免直接暴露实体对象
4. 完善文档，记录 API 设计和使用方法 