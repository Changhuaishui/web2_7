
## TF-IDF改进公式与分析

### 1. 原有TF-IDF公式

#### 1.1 基础公式

$$
TF(t,d) = \frac{n_{t,d}}{\sum_{k} n_{k,d}}
$$

$$
IDF(t) = \log\frac{N}{df_t + 1}
$$

$$
TFIDF(t,d) = 10 \times TF(t,d) \times IDF(t)
$$

其中：

- $t$: 词项（term）
- $d$: 文档（document）
- $n_{t,d}$: 词t在文档d中的出现次数
- $N$: 文档集合中的总文档数
- $df_t$: 包含词t的文档数量

#### 1.2 原有公式的局限性

1. 没有考虑词频饱和问题
2. 没有考虑文档长度归一化
3. 没有考虑标题权重
4. 没有考虑位置权重
5. 没有考虑关键词匹配权重

### 2. 改进后的基础公式

当前实现的BM25算法（改进的TF-IDF）：

$$
Score(t,d) = \sum_{t \in q} \frac{tf(t,d) \times (k_1 + 1)}{tf(t,d) + k_1 \times (1 - b + b \times \frac{|d|}{avgdl})} \times \log\frac{N}{df(t) + 1}
$$

#### 2.1 关键参数说明

1. **词频饱和参数 $k_1$**（当前值：1.2）

   - 作用：控制词频对最终得分的影响程度
   - 实际意义：
     - 防止某个词在文档中重复出现过多时过度影响最终得分
     - 避免长文档中高频词对文档主题的过度影响
     - 使得算法对词频的敏感度更合理
   - 效果：
     - 词频较低时，得分随词频增加而快速上升
     - 词频较高时，得分的增长速度会逐渐减缓
     - 最终会趋于一个上限值，避免过度饱和
2. **文档长度归一化参数 $b$**（当前值：0.75）

   - 作用：控制文档长度对词频得分的影响程度
   - 实际意义：
     - 平衡长文档和短文档的得分差异
     - 防止长文档中的词频被过度放大
     - 使得不同长度的文档可以公平比较
   - 效果：
     - $b = 0$ 时，完全忽略文档长度的影响
     - $b = 1$ 时，完全考虑文档长度的影响
     - $b = 0.75$ 时，在保持词频重要性的同时，适度考虑文档长度

#### 2.2 时间空间复杂度分析

**参数定义：**

- $L_T$: 文章标题长度
- $L_C$: 文章内容长度
- $L_{AKS}$: 文章关键词字符串长度
- $N_P$: 预定义标签数量（常数，12）
- $N_{KPM}$: 单个标签的最大关键词数量
- $L_{KW}$: 关键词平均长度
- $L_{tag}$: 标签字符串平均长度
- $M_{TA}$: 每篇文章最大标签数（常数，5）

**时间复杂度：**

- 缓存命中：$O(1)$
- 缓存未命中：$O(L_T + L_C + L_{AKS} + N_{KPM} \cdot L_T \cdot L_{KW})$
  - 主导项：$N_{KPM} \cdot L_T \cdot L_{KW}$（TF-IDF计算中的嵌套循环）

**空间复杂度：**

- 缓存未命中：$O(L_T + L_C + L_{AKS} + N_{KPM} \cdot L_{KW})$
  - 主要贡献：
    1. 文本副本：$O(L_T + L_C)$
    2. 词频表：$O(L_T + L_C)$
    3. 关键词匹配结构：$O(N_{KPM})$
    4. 日志字符串：$O(L_T + N_{KPM} \cdot L_{KW})$

### 3. 性能分析

#### 3.1 时间复杂度

- 原始实现：$O(n \times m)$，其中n为文档数，m为平均词数
- 并行优化后：$O(\frac{n \times m}{p})$，其中p为并行度

#### 3.2 空间复杂度

- 原始实现：$O(n \times m)$
- 优化后：$O(n \times m + c)$，其中c为缓存大小

#### 3.3 缓存效率

- 缓存命中率：$\eta = \frac{hits}{hits + misses}$
- 预期提升：30-50%的性能提升

### 4. 优化效果预期

1. **处理速度**

   - 单文档处理：提升20-30%
   - 批量处理：提升40-60%
2. **资源利用**

   - CPU利用率：提升至70-80%
   - 内存使用：增加10-15%（用于缓存）
3. **可扩展性**

   - 支持动态扩展并行度
   - 适应不同规模的文档集合

### 5. 并行处理优化

#### 5.1 文档预处理阶段

$$
DF_{parallel}(t) = \sum_{d \in D_{parallel}} \begin{cases} 1, & \text{if } t \in d \\ 0, & \text{otherwise} \end{cases}
$$

其中：

- $D_{parallel}$ 表示并行处理的文档集合
- 使用线程安全的累加器确保准确性

#### 5.2 词频计算优化

$$
TF_{optimized}(t,d) = \frac{tf(t,d) \times (k_1 + 1)}{tf(t,d) + k_1 \times (1 - b + b \times \frac{|d|}{avgdl})}
$$

其中：

- $k_1$: 词频饱和参数（1.2）
- $b$: 长度归一化参数（0.75）
- $|d|$: 文档长度
- $avgdl$: 平均文档长度

#### 5.3 IDF计算

$$
IDF(t) = \log\frac{N}{df(t) + 1}
$$

其中：

- $N$: 总文档数
- $df(t)$: 包含词t的文档数
- 加1是为了避免分母为0

# TF-IDF并行处理优化任务列表



## 1. 文档预处理并行化

- [ ] 实现 `calculateDocumentFrequencies`方法的并行流处理
- [ ] 添加线程安全的文档频率统计
- [ ] 添加性能监控代码

## 2. TF-IDF计算并行化

- [ ] 实现 `calculateTFIDF`方法的并行处理
- [ ] 优化词频计算过程
- [ ] 添加并行流处理

## 3. 关键词提取并行化

- [ ] 优化 `extractKeywords`方法的排序过程
- [ ] 实现并行流排序
- [ ] 添加结果验证机制

## 4. 批量文档处理优化

- [ ] 实现 `calculateBatchTFIDF`方法
- [ ] 配置合适的线程池大小
- [ ] 添加任务队列管理

## 5. 缓存优化

- [ ] 实现IDF值缓存机制
- [ ] 使用 `ConcurrentHashMap`存储缓存
- [ ] 添加缓存清理策略

## 6. 性能监控与测试

- [ ] 添加详细的性能监控代码
- [ ] 使用JMH进行基准测试
- [ ] 记录各阶段执行时间

## 优先级

1. 文档预处理并行化
2. IDF缓存优化
3. TF-IDF计算并行化
4. 批量处理优化
5. 其他优化项
### 6. 注意事项

1. **数据一致性**

   - 确保并行计算结果的准确性
   - 维护线程安全的数据结构
2. **资源管理**

   - 动态调整线程池大小
   - 监控内存使用情况
3. **降级策略**

   - 在资源紧张时自动降级
   - 保持基本功能可用性
